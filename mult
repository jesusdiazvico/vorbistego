lib/floor1.c:  int maxposit=info->postlist[1];
lib/floor1.c:  oggpack_write(opb,info->partitions,5); /* only 0 to 31 legal */
lib/floor1.c:  for(j=0;j<info->partitions;j++){
lib/floor1.c:    oggpack_write(opb,info->partitionclass[j],4); /* only 0 to 15 legal */
lib/floor1.c:    if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
lib/floor1.c:    oggpack_write(opb,info->class_dim[j]-1,3); /* 1 to 8 */
lib/floor1.c:    oggpack_write(opb,info->class_subs[j],2); /* 0 to 3 */
lib/floor1.c:    if(info->class_subs[j])oggpack_write(opb,info->class_book[j],8);
lib/floor1.c:    for(k=0;k<(1<<info->class_subs[j]);k++)
lib/floor1.c:      oggpack_write(opb,info->class_subbook[j][k]+1,8);
lib/floor1.c:  oggpack_write(opb,info->mult-1,2);     /* only 1,2,3,4 legal now */
lib/floor1.c:  for(j=0,k=0;j<info->partitions;j++){
lib/floor1.c:    count+=info->class_dim[info->partitionclass[j]];
lib/floor1.c:      oggpack_write(opb,info->postlist[k+2],rangebits);
lib/floor1.c:  info->partitions=oggpack_read(opb,5); /* only 0 to 31 legal */
lib/floor1.c:  for(j=0;j<info->partitions;j++){
lib/floor1.c:    info->partitionclass[j]=oggpack_read(opb,4); /* only 0 to 15 legal */
lib/floor1.c:    if(info->partitionclass[j]<0)goto err_out;
lib/floor1.c:    if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
lib/floor1.c:    info->class_dim[j]=oggpack_read(opb,3)+1; /* 1 to 8 */
lib/floor1.c:    info->class_subs[j]=oggpack_read(opb,2); /* 0,1,2,3 bits */
lib/floor1.c:    if(info->class_subs[j]<0)
lib/floor1.c:    if(info->class_subs[j])info->class_book[j]=oggpack_read(opb,8);
lib/floor1.c:    if(info->class_book[j]<0 || info->class_book[j]>=ci->books)
lib/floor1.c:    for(k=0;k<(1<<info->class_subs[j]);k++){
lib/floor1.c:      info->class_subbook[j][k]=oggpack_read(opb,8)-1;
lib/floor1.c:      if(info->class_subbook[j][k]<-1 || info->class_subbook[j][k]>=ci->books)
lib/floor1.c:  info->mult=oggpack_read(opb,2)+1;     /* only 1,2,3,4 legal now */
lib/floor1.c:  for(j=0,k=0;j<info->partitions;j++){
lib/floor1.c:    count+=info->class_dim[info->partitionclass[j]];
lib/floor1.c:      int t=info->postlist[k+2]=oggpack_read(opb,rangebits);
lib/floor1.c:  info->postlist[0]=0;
lib/floor1.c:  info->postlist[1]=1<<rangebits;
lib/floor1.c:    for(j=0;j<count+2;j++)sortpointer[j]=info->postlist+j;
lib/floor1.c:  look->n=info->postlist[1];
lib/floor1.c:  for(i=0;i<info->partitions;i++)n+=info->class_dim[info->partitionclass[i]];
lib/floor1.c:  for(i=0;i<n;i++)sortpointer[i]=info->postlist+i;
lib/floor1.c:  for(i=0;i<n;i++)look->forward_index[i]=sortpointer[i]-info->postlist;
lib/floor1.c:  for(i=0;i<n;i++)look->sorted_index[i]=info->postlist[look->forward_index[i]];
lib/floor1.c:  switch(info->mult){
lib/floor1.c:    int currentx=info->postlist[i+2];
lib/floor1.c:      int x=info->postlist[j];
lib/floor1.c:      if(mdct[i]+info->twofitatten>=flr[i]){
lib/floor1.c:    int weight=nb*info->twofitweight/(na+1);
lib/floor1.c:  if(mdct[x]+info->twofitatten>=mask[x]){
lib/floor1.c:    if(y+info->maxover<val)return(1);
lib/floor1.c:    if(y-info->maxunder>val)return(1);
lib/floor1.c:    if(mdct[x]+info->twofitatten>=mask[x]){
lib/floor1.c:        if(y+info->maxover<val)return(1);
lib/floor1.c:        if(y-info->maxunder>val)return(1);
lib/floor1.c:  if(info->maxover*info->maxover/n>info->maxerr)return(0);
lib/floor1.c:  if(info->maxunder*info->maxunder/n>info->maxerr)return(0);
lib/floor1.c:  if(mse/n>info->maxerr)return(1);
lib/floor1.c:          int lx=info->postlist[ln];
lib/floor1.c:          int hx=info->postlist[hn];
lib/floor1.c:      int x0=info->postlist[ln];
lib/floor1.c:      int x1=info->postlist[hn];
lib/floor1.c:      int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
lib/floor1.c:      switch(info->mult){
lib/floor1.c:      int x0=info->postlist[ln];
lib/floor1.c:      int x1=info->postlist[hn];
lib/floor1.c:      int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
lib/floor1.c:    for(i=0,j=2;i<info->partitions;i++){
lib/floor1.c:      int class=info->partitionclass[i];
lib/floor1.c:      int cdim=info->class_dim[class];
lib/floor1.c:      int csubbits=info->class_subs[class];
lib/floor1.c:          int booknum=info->class_subbook[class][k];
lib/floor1.c:            maxval[k]=sbooks[info->class_subbook[class][k]]->entries;
lib/floor1.c:          vorbis_book_encode(books+info->class_book[class],cval,opb);
lib/floor1.c:        int book=info->class_subbook[class][bookas[k]];
lib/floor1.c:      int ly=post[0]*info->mult;
lib/floor1.c:          hy*=info->mult;
lib/floor1.c:          hx=info->postlist[current];
lib/floor1.c:    for(i=0,j=2;i<info->partitions;i++){
lib/floor1.c:      int class=info->partitionclass[i];
lib/floor1.c:      int cdim=info->class_dim[class];
lib/floor1.c:      int csubbits=info->class_subs[class];
lib/floor1.c:        cval=vorbis_book_decode(books+info->class_book[class],&vb->opb);
lib/floor1.c:        int book=info->class_subbook[class][cval&(csub-1)];
lib/floor1.c:      int predicted=render_point(info->postlist[look->loneighbor[i-2]],
lib/floor1.c:                                 info->postlist[look->hineighbor[i-2]],
lib/floor1.c:                                 info->postlist[i]);
lib/floor1.c:    int ly=fit_value[0]*info->mult;
lib/floor1.c:        hy*=info->mult;
lib/floor1.c:        hx=info->postlist[current];
lib/res0.c:        if((info->secondstages[j]>>k)&1){
lib/res0.c:              acc?(float)acc/(look->resvals[j]*info->grouping):0);
lib/res0.c:  oggpack_write(opb,info->begin,24);
lib/res0.c:  oggpack_write(opb,info->end,24);
lib/res0.c:  oggpack_write(opb,info->grouping-1,24);  /* residue vectors to group and
lib/res0.c:  oggpack_write(opb,info->partitions-1,6); /* possible partition choices */
lib/res0.c:  oggpack_write(opb,info->groupbook,8);  /* group huffman book */
lib/res0.c:  for(j=0;j<info->partitions;j++){
lib/res0.c:    if(ilog(info->secondstages[j])>3){
lib/res0.c:      oggpack_write(opb,info->secondstages[j],3);
lib/res0.c:      oggpack_write(opb,info->secondstages[j]>>3,5);
lib/res0.c:      oggpack_write(opb,info->secondstages[j],4); /* trailing zero */
lib/res0.c:    acc+=icount(info->secondstages[j]);
lib/res0.c:    oggpack_write(opb,info->booklist[j],8);
lib/res0.c:  info->begin=oggpack_read(opb,24);
lib/res0.c:  info->end=oggpack_read(opb,24);
lib/res0.c:  info->grouping=oggpack_read(opb,24)+1;
lib/res0.c:  info->partitions=oggpack_read(opb,6)+1;
lib/res0.c:  info->groupbook=oggpack_read(opb,8);
lib/res0.c:  if(info->groupbook<0)goto errout;
lib/res0.c:  for(j=0;j<info->partitions;j++){
lib/res0.c:    info->secondstages[j]=cascade;
lib/res0.c:    info->booklist[j]=book;
lib/res0.c:  if(info->groupbook>=ci->books)goto errout;
lib/res0.c:    if(info->booklist[j]>=ci->books)goto errout;
lib/res0.c:    if(ci->book_param[info->booklist[j]]->maptype==0)goto errout;
lib/res0.c:    int entries = ci->book_param[info->groupbook]->entries;
lib/res0.c:    int dim = ci->book_param[info->groupbook]->dim;
lib/res0.c:      partvals *= info->partitions;
lib/res0.c:  look->parts=info->partitions;
lib/res0.c:  look->phrasebook=ci->fullbooks+info->groupbook;
lib/res0.c:    int stages=ilog(info->secondstages[j]);
lib/res0.c:        if(info->secondstages[j]&(1<<k)){
lib/res0.c:          look->partbooks[j][k]=ci->fullbooks+info->booklist[acc++];
lib/res0.c:  int samples_per_partition=info->grouping;
lib/res0.c:  int possible_partitions=info->partitions;
lib/res0.c:  int n=info->end-info->begin;
lib/res0.c:    int offset=i*samples_per_partition+info->begin;
lib/res0.c:        if(max<=info->classmetric1[k] &&
lib/res0.c:           (info->classmetric2[k]<0 || (int)ent<info->classmetric2[k]))
lib/res0.c:  int samples_per_partition=info->grouping;
lib/res0.c:  int possible_partitions=info->partitions;
lib/res0.c:  int n=info->end-info->begin;
lib/res0.c:  for(i=0,l=info->begin/ch;i<partvals;i++){
lib/res0.c:      if(magmax<=info->classmetric1[j] &&
lib/res0.c:         angmax<=info->classmetric2[j])
lib/res0.c:  int samples_per_partition=info->grouping;
lib/res0.c:  int possible_partitions=info->partitions;
lib/res0.c:  int n=info->end-info->begin;
lib/res0.c:    for(j=info->begin;j<end;j++){
lib/res0.c:        long offset=i*samples_per_partition+info->begin;
lib/res0.c:          if(info->secondstages[partword[j][i]]&(1<<s)){
lib/res0.c:  int samples_per_partition=info->grouping;
lib/res0.c:  int end=(info->end<max?info->end:max);
lib/res0.c:  int n=end-info->begin;
lib/res0.c:            long offset=info->begin+i*samples_per_partition;
lib/res0.c:            if(info->secondstages[partword[j][l][k]]&(1<<s)){
lib/res0.c:  int samples_per_partition=info->grouping;
lib/res0.c:  int end=(info->end<max?info->end:max);
lib/res0.c:  int n=end-info->begin;
lib/res0.c:          if(info->secondstages[partword[l][k]]&(1<<s)){
lib/res0.c:                                          i*samples_per_partition+info->begin,ch,
lib/floor0.c:  info->order=oggpack_read(opb,8);
lib/floor0.c:  info->rate=oggpack_read(opb,16);
lib/floor0.c:  info->barkmap=oggpack_read(opb,16);
lib/floor0.c:  info->ampbits=oggpack_read(opb,6);
lib/floor0.c:  info->ampdB=oggpack_read(opb,8);
lib/floor0.c:  info->numbooks=oggpack_read(opb,4)+1;
lib/floor0.c:  if(info->order<1)goto err_out;
lib/floor0.c:  if(info->rate<1)goto err_out;
lib/floor0.c:  if(info->barkmap<1)goto err_out;
lib/floor0.c:  if(info->numbooks<1)goto err_out;
lib/floor0.c:  for(j=0;j<info->numbooks;j++){
lib/floor0.c:    info->books[j]=oggpack_read(opb,8);
lib/floor0.c:    if(info->books[j]<0 || info->books[j]>=ci->books)goto err_out;
lib/floor0.c:    float scale=look->ln/toBARK(info->rate/2.f);
lib/floor0.c:      int val=floor( toBARK((info->rate/2.f)/n*j)
lib/floor0.c:  look->m=info->order;
lib/floor0.c:  look->ln=info->barkmap;
lib/floor0.c:  int ampraw=oggpack_read(&vb->opb,info->ampbits);
lib/floor0.c:    long maxval=(1<<info->ampbits)-1;
lib/floor0.c:    float amp=(float)ampraw/maxval*info->ampdB;
lib/floor0.c:    int booknum=oggpack_read(&vb->opb,_ilog(info->numbooks));
lib/floor0.c:    if(booknum!=-1 && booknum<info->numbooks){ /* be paranoid */
lib/floor0.c:      codebook *b=ci->fullbooks+info->books[booknum];
lib/floor0.c:                        lsp,look->m,amp,(float)info->ampdB);
lib/mapping0.c:  if(info->submaps>1){
lib/mapping0.c:    oggpack_write(opb,info->submaps-1,4);
lib/mapping0.c:  if(info->coupling_steps>0){
lib/mapping0.c:    oggpack_write(opb,info->coupling_steps-1,8);
lib/mapping0.c:    for(i=0;i<info->coupling_steps;i++){
lib/mapping0.c:      oggpack_write(opb,info->coupling_mag[i],ilog(vi->channels));
lib/mapping0.c:      oggpack_write(opb,info->coupling_ang[i],ilog(vi->channels));
lib/mapping0.c:  if(info->submaps>1){
lib/mapping0.c:      oggpack_write(opb,info->chmuxlist[i],4);
lib/mapping0.c:  for(i=0;i<info->submaps;i++){
lib/mapping0.c:    oggpack_write(opb,info->floorsubmap[i],8);
lib/mapping0.c:    oggpack_write(opb,info->residuesubmap[i],8);
lib/mapping0.c:    info->submaps=oggpack_read(opb,4)+1;
lib/mapping0.c:    if(info->submaps<=0)goto err_out;
lib/mapping0.c:    info->submaps=1;
lib/mapping0.c:    info->coupling_steps=oggpack_read(opb,8)+1;
lib/mapping0.c:    if(info->coupling_steps<=0)goto err_out;
lib/mapping0.c:    for(i=0;i<info->coupling_steps;i++){
lib/mapping0.c:      int testM=info->coupling_mag[i]=oggpack_read(opb,ilog(vi->channels));
lib/mapping0.c:      int testA=info->coupling_ang[i]=oggpack_read(opb,ilog(vi->channels));
lib/mapping0.c:  if(info->submaps>1){
lib/mapping0.c:      info->chmuxlist[i]=oggpack_read(opb,4);
lib/mapping0.c:      if(info->chmuxlist[i]>=info->submaps || info->chmuxlist[i]<0)goto err_out;
lib/mapping0.c:  for(i=0;i<info->submaps;i++){
lib/mapping0.c:    info->floorsubmap[i]=oggpack_read(opb,8);
lib/mapping0.c:    if(info->floorsubmap[i]>=ci->floors || info->floorsubmap[i]<0)goto err_out;
lib/mapping0.c:    info->residuesubmap[i]=oggpack_read(opb,8);
lib/mapping0.c:    if(info->residuesubmap[i]>=ci->residues || info->residuesubmap[i]<0)goto err_out;
lib/mapping0.c:      int submap=info->chmuxlist[i];
lib/mapping0.c:      if(ci->floor_type[info->floorsubmap[submap]]!=1)return(-1);
lib/mapping0.c:        floor1_fit(vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:          floor1_fit(vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:          floor1_fit(vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:            floor1_interpolate_fit(vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:            floor1_interpolate_fit(vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:    if(info->coupling_steps){
lib/mapping0.c:        int submap=info->chmuxlist[i];
lib/mapping0.c:        nonzero[i]=floor1_encode(opb,vb,b->flr[info->floorsubmap[submap]],
lib/mapping0.c:      if(info->coupling_steps){
lib/mapping0.c:      for(i=0;i<info->submaps;i++){
lib/mapping0.c:        int resnum=info->residuesubmap[i];
lib/mapping0.c:          if(info->chmuxlist[j]==i){
lib/mapping0.c:          if(info->chmuxlist[j]==i)
lib/mapping0.c:    int submap=info->chmuxlist[i];
lib/mapping0.c:    floormemo[i]=_floor_P[ci->floor_type[info->floorsubmap[submap]]]->
lib/mapping0.c:      inverse1(vb,b->flr[info->floorsubmap[submap]]);
lib/mapping0.c:  for(i=0;i<info->coupling_steps;i++){
lib/mapping0.c:    if(nonzero[info->coupling_mag[i]] ||
lib/mapping0.c:       nonzero[info->coupling_ang[i]]){
lib/mapping0.c:      nonzero[info->coupling_mag[i]]=1;
lib/mapping0.c:      nonzero[info->coupling_ang[i]]=1;
lib/mapping0.c:  for(i=0;i<info->submaps;i++){
lib/mapping0.c:      if(info->chmuxlist[j]==i){
lib/mapping0.c:    _residue_P[ci->residue_type[info->residuesubmap[i]]]->
lib/mapping0.c:      inverse(vb,b->residue[info->residuesubmap[i]],
lib/mapping0.c:  for(i=info->coupling_steps-1;i>=0;i--){
lib/mapping0.c:    float *pcmM=vb->pcm[info->coupling_mag[i]];
lib/mapping0.c:    float *pcmA=vb->pcm[info->coupling_ang[i]];
lib/mapping0.c:    int submap=info->chmuxlist[i];
lib/mapping0.c:    _floor_P[ci->floor_type[info->floorsubmap[submap]]]->
lib/mapping0.c:      inverse2(vb,b->flr[info->floorsubmap[submap]],
